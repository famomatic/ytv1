package client

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strings"
	"testing"

	"github.com/famomatic/ytv1/internal/innertube"
)

type testLogger struct {
	warnings []string
}

func (l *testLogger) Warnf(format string, args ...any) {
	l.warnings = append(l.warnings, fmt.Sprintf(format, args...))
}

func TestGetSubtitleTracks(t *testing.T) {
	videoID := "jNQXAC9IVRw"
	c := testClientWithSession(videoID, innertube.Format{Itag: 140, URL: "https://example.com/a"}, testPlayerJS())
	c.sessions[videoID] = videoSession{
		Response: &innertube.PlayerResponse{
			VideoDetails: innertube.VideoDetails{VideoID: videoID},
			Captions: innertube.Captions{
				PlayerCaptionsTracklistRenderer: innertube.PlayerCaptionsTracklistRenderer{
					CaptionTracks: []innertube.CaptionTrack{
						{
							BaseURL:      "https://caption.local/api?lang=en",
							LanguageCode: "en",
							VssID:        ".en",
							Name:         innertube.LangText{SimpleText: "English"},
						},
						{
							BaseURL:      "https://caption.local/api?lang=ko",
							LanguageCode: "ko",
							VssID:        "a.ko",
							Kind:         "asr",
							Name:         innertube.LangText{SimpleText: "Korean (auto-generated)"},
						},
					},
				},
			},
		},
		PlayerURL: "/s/player/test/base.js",
	}

	tracks, err := c.GetSubtitleTracks(context.Background(), videoID)
	if err != nil {
		t.Fatalf("GetSubtitleTracks() error = %v", err)
	}
	if len(tracks) != 2 {
		t.Fatalf("tracks len=%d, want 2", len(tracks))
	}
	if tracks[1].LanguageCode != "ko" || !tracks[1].AutoGenerated {
		t.Fatalf("unexpected second track: %+v", tracks[1])
	}
}

func TestGetTranscript(t *testing.T) {
	videoID := "jNQXAC9IVRw"
	httpClient := &http.Client{
		Transport: roundTripFunc(func(r *http.Request) (*http.Response, error) {
			if strings.HasPrefix(r.URL.Host, "caption.local") {
				body := `<transcript><text start="0.0" dur="1.2">hello</text><text start="1.2" dur="0.8">world</text></transcript>`
				return &http.Response{
					StatusCode: http.StatusOK,
					Header:     make(http.Header),
					Body:       io.NopCloser(bytes.NewBufferString(body)),
				}, nil
			}
			t.Fatalf("unexpected request: %s", r.URL.String())
			return nil, nil
		}),
	}
	c := &Client{
		config: Config{HTTPClient: httpClient},
		sessions: map[string]videoSession{
			videoID: {
				Response: &innertube.PlayerResponse{
					VideoDetails: innertube.VideoDetails{VideoID: videoID},
					Captions: innertube.Captions{
						PlayerCaptionsTracklistRenderer: innertube.PlayerCaptionsTracklistRenderer{
							CaptionTracks: []innertube.CaptionTrack{
								{
									BaseURL:      "https://caption.local/api?lang=en",
									LanguageCode: "en",
									Name:         innertube.LangText{SimpleText: "English"},
								},
							},
						},
					},
				},
				PlayerURL: "/s/player/test/base.js",
			},
		},
	}

	got, err := c.GetTranscript(context.Background(), videoID, "en")
	if err != nil {
		t.Fatalf("GetTranscript() error = %v", err)
	}
	if len(got.Entries) != 2 {
		t.Fatalf("entries len=%d, want 2", len(got.Entries))
	}
	if got.Entries[0].Text != "hello" {
		t.Fatalf("entry[0] text=%q, want hello", got.Entries[0].Text)
	}
}

func TestGetPlaylist(t *testing.T) {
	html := `<html><script>var ytInitialData = {"metadata":{"playlistMetadataRenderer":{"title":"My Playlist"}},"contents":[{"playlistVideoRenderer":{"videoId":"aaaaaaaaaaa","title":{"simpleText":"one"},"shortBylineText":{"runs":[{"text":"author1"}]},"lengthText":{"simpleText":"1:00"}}},{"playlistVideoRenderer":{"videoId":"bbbbbbbbbbb","title":{"runs":[{"text":"two"}]},"shortBylineText":{"runs":[{"text":"author2"}]},"lengthText":{"simpleText":"2:00"}}}]};</script></html>`
	httpClient := &http.Client{
		Transport: roundTripFunc(func(r *http.Request) (*http.Response, error) {
			if r.Method == http.MethodGet && r.URL.Path == "/playlist" {
				return &http.Response{
					StatusCode: http.StatusOK,
					Header:     make(http.Header),
					Body:       io.NopCloser(bytes.NewBufferString(html)),
				}, nil
			}
			t.Fatalf("unexpected request: %s", r.URL.String())
			return nil, nil
		}),
	}

	c := &Client{config: Config{HTTPClient: httpClient}}
	got, err := c.GetPlaylist(context.Background(), "https://www.youtube.com/playlist?list=PL1234567890")
	if err != nil {
		t.Fatalf("GetPlaylist() error = %v", err)
	}
	if got.Title != "My Playlist" {
		t.Fatalf("title=%q, want %q", got.Title, "My Playlist")
	}
	if len(got.Items) != 2 {
		t.Fatalf("items len=%d, want 2", len(got.Items))
	}
	if got.Items[0].DurationSec != 60 || got.Items[1].DurationSec != 120 {
		t.Fatalf("unexpected parsed duration seconds: %+v", got.Items)
	}
}

func TestGetPlaylist_ContinuationSkipsInvalidToken(t *testing.T) {
	html := `<html><script>var ytInitialData = {"responseContext":{"visitorData":"visitor"},"metadata":{"playlistMetadataRenderer":{"title":"My Playlist"}},"contents":[{"playlistVideoRenderer":{"videoId":"aaaaaaaaaaa","title":{"simpleText":"one"},"shortBylineText":{"runs":[{"text":"author1"}]},"lengthText":{"simpleText":"1:00"}}},{"playlistVideoRenderer":{"videoId":"bbbbbbbbbbb","title":{"runs":[{"text":"two"}]},"shortBylineText":{"runs":[{"text":"author2"}]},"lengthText":{"simpleText":"2:00"}}},{"continuationItemRenderer":{"continuationEndpoint":{"continuationCommand":{"token":"bad-token"}}}},{"continuationItemRenderer":{"continuationEndpoint":{"continuationCommand":{"token":"good-token-1"}}}}]};</script></html>`
	httpClient := &http.Client{
		Transport: roundTripFunc(func(r *http.Request) (*http.Response, error) {
			if r.Method == http.MethodGet && r.URL.Path == "/playlist" {
				return &http.Response{
					StatusCode: http.StatusOK,
					Header:     make(http.Header),
					Body:       io.NopCloser(bytes.NewBufferString(html)),
				}, nil
			}
			if r.Method == http.MethodPost && r.URL.Path == "/youtubei/v1/browse" {
				var reqBody struct {
					Continuation string `json:"continuation"`
				}
				if err := json.NewDecoder(r.Body).Decode(&reqBody); err != nil {
					t.Fatalf("decode browse request: %v", err)
				}
				switch reqBody.Continuation {
				case "bad-token":
					return jsonResponse(t, map[string]any{
						"onResponseReceivedActions": []any{
							map[string]any{
								"appendContinuationItemsAction": map[string]any{
									"continuationItems": []any{},
								},
							},
						},
					}), nil
				case "good-token-1":
					return jsonResponse(t, map[string]any{
						"onResponseReceivedActions": []any{
							map[string]any{
								"appendContinuationItemsAction": map[string]any{
									"continuationItems": []any{
										map[string]any{
											"playlistVideoRenderer": map[string]any{
												"videoId":         "ccccccccccc",
												"title":           map[string]any{"simpleText": "three"},
												"shortBylineText": map[string]any{"runs": []any{map[string]any{"text": "author3"}}},
												"lengthText":      map[string]any{"simpleText": "3:00"},
											},
										},
										map[string]any{
											"continuationItemRenderer": map[string]any{
												"continuationEndpoint": map[string]any{
													"continuationCommand": map[string]any{
														"token": "good-token-2",
													},
												},
											},
										},
									},
								},
							},
						},
					}), nil
				case "good-token-2":
					return jsonResponse(t, map[string]any{
						"onResponseReceivedActions": []any{
							map[string]any{
								"appendContinuationItemsAction": map[string]any{
									"continuationItems": []any{
										map[string]any{
											"playlistVideoRenderer": map[string]any{
												"videoId":         "ddddddddddd",
												"title":           map[string]any{"simpleText": "four"},
												"shortBylineText": map[string]any{"runs": []any{map[string]any{"text": "author4"}}},
												"lengthText":      map[string]any{"simpleText": "4:00"},
											},
										},
									},
								},
							},
						},
					}), nil
				default:
					t.Fatalf("unexpected continuation token: %q", reqBody.Continuation)
				}
			}
			t.Fatalf("unexpected request: %s", r.URL.String())
			return nil, nil
		}),
	}

	c := &Client{config: Config{HTTPClient: httpClient}}
	got, err := c.GetPlaylist(context.Background(), "https://www.youtube.com/playlist?list=PL1234567890")
	if err != nil {
		t.Fatalf("GetPlaylist() error = %v", err)
	}
	if len(got.Items) != 4 {
		t.Fatalf("items len=%d, want 4", len(got.Items))
	}
	if got.Items[2].VideoID != "ccccccccccc" || got.Items[3].VideoID != "ddddddddddd" {
		t.Fatalf("unexpected continuation items: %+v", got.Items)
	}
	if got.ContinuationStats.Requested < 2 || got.ContinuationStats.Succeeded < 2 {
		t.Fatalf("unexpected continuation stats: %+v", got.ContinuationStats)
	}
}

func TestGetPlaylist_ContinuationErrorUsesLogger(t *testing.T) {
	html := `<html><script>var ytInitialData = {"responseContext":{"visitorData":"visitor"},"metadata":{"playlistMetadataRenderer":{"title":"My Playlist"}},"contents":[{"playlistVideoRenderer":{"videoId":"aaaaaaaaaaa","title":{"simpleText":"one"},"shortBylineText":{"runs":[{"text":"author1"}]},"lengthText":{"simpleText":"1:00"}}},{"continuationItemRenderer":{"continuationEndpoint":{"continuationCommand":{"token":"bad-token"}}}},{"continuationItemRenderer":{"continuationEndpoint":{"continuationCommand":{"token":"good-token"}}}}]};</script></html>`
	httpClient := &http.Client{
		Transport: roundTripFunc(func(r *http.Request) (*http.Response, error) {
			if r.Method == http.MethodGet && r.URL.Path == "/playlist" {
				return &http.Response{
					StatusCode: http.StatusOK,
					Header:     make(http.Header),
					Body:       io.NopCloser(bytes.NewBufferString(html)),
				}, nil
			}
			if r.Method == http.MethodPost && r.URL.Path == "/youtubei/v1/browse" {
				var reqBody struct {
					Continuation string `json:"continuation"`
				}
				if err := json.NewDecoder(r.Body).Decode(&reqBody); err != nil {
					t.Fatalf("decode browse request: %v", err)
				}
				switch reqBody.Continuation {
				case "bad-token":
					return &http.Response{
						StatusCode: http.StatusInternalServerError,
						Header:     make(http.Header),
						Body:       io.NopCloser(bytes.NewBufferString(`internal`)),
					}, nil
				case "good-token":
					return jsonResponse(t, map[string]any{
						"onResponseReceivedActions": []any{
							map[string]any{
								"appendContinuationItemsAction": map[string]any{
									"continuationItems": []any{
										map[string]any{
											"playlistVideoRenderer": map[string]any{
												"videoId":         "bbbbbbbbbbb",
												"title":           map[string]any{"simpleText": "two"},
												"shortBylineText": map[string]any{"runs": []any{map[string]any{"text": "author2"}}},
												"lengthText":      map[string]any{"simpleText": "2:00"},
											},
										},
									},
								},
							},
						},
					}), nil
				}
			}
			t.Fatalf("unexpected request: %s", r.URL.String())
			return nil, nil
		}),
	}
	logger := &testLogger{}
	c := &Client{
		config:   Config{HTTPClient: httpClient},
		logger:   logger,
		sessions: map[string]videoSession{},
	}
	got, err := c.GetPlaylist(context.Background(), "https://www.youtube.com/playlist?list=PL1234567890")
	if err != nil {
		t.Fatalf("GetPlaylist() error = %v", err)
	}
	if len(got.Items) != 2 {
		t.Fatalf("items len=%d, want 2", len(got.Items))
	}
	if len(logger.warnings) == 0 {
		t.Fatalf("expected continuation warning to be logged")
	}
	if got.ContinuationStats.Failed == 0 {
		t.Fatalf("expected failed continuation stats")
	}
	if len(got.ContinuationWarnings) == 0 || got.ContinuationWarnings[0].HTTPStatus != http.StatusInternalServerError {
		t.Fatalf("unexpected continuation warnings: %+v", got.ContinuationWarnings)
	}
}

func TestExtractPlaylistID(t *testing.T) {
	id, err := ExtractPlaylistID("https://www.youtube.com/watch?v=jNQXAC9IVRw&list=PLabc123")
	if err != nil {
		t.Fatalf("ExtractPlaylistID() error = %v", err)
	}
	if id != "PLabc123" {
		t.Fatalf("ExtractPlaylistID()=%q, want %q", id, "PLabc123")
	}
}

func TestFindContinuationTokens_Variants(t *testing.T) {
	root := map[string]any{
		"a": map[string]any{
			"continuationCommand": map[string]any{"token": "tok-a"},
		},
		"b": map[string]any{
			"nextContinuationData": map[string]any{"continuation": "tok-b"},
		},
		"c": map[string]any{
			"reloadContinuationData": map[string]any{"continuation": "tok-c"},
		},
		"d": map[string]any{
			"continuationCommand": map[string]any{"token": "tok-a"},
		},
	}
	got := findContinuationTokens(root)
	if len(got) != 3 {
		t.Fatalf("tokens len=%d, want 3 (got=%v)", len(got), got)
	}
	seen := map[string]struct{}{}
	for _, token := range got {
		seen[token] = struct{}{}
	}
	for _, want := range []string{"tok-a", "tok-b", "tok-c"} {
		if _, ok := seen[want]; !ok {
			t.Fatalf("missing token %q in %v", want, got)
		}
	}
}

func jsonResponse(t *testing.T, payload any) *http.Response {
	t.Helper()
	raw, err := json.Marshal(payload)
	if err != nil {
		t.Fatalf("marshal json response: %v", err)
	}
	return &http.Response{
		StatusCode: http.StatusOK,
		Header:     make(http.Header),
		Body:       io.NopCloser(bytes.NewReader(raw)),
	}
}

func TestParseDurationTextSeconds(t *testing.T) {
	tests := []struct {
		text string
		want int64
	}{
		{text: "1:00", want: 60},
		{text: "02:03", want: 123},
		{text: "1:02:03", want: 3723},
		{text: "", want: 0},
		{text: "abc", want: 0},
	}
	for _, tt := range tests {
		if got := parseDurationTextSeconds(tt.text); got != tt.want {
			t.Fatalf("parseDurationTextSeconds(%q) = %d, want %d", tt.text, got, tt.want)
		}
	}
}

func TestChooseSubtitleTrack_PolicyPrefersManualFallback(t *testing.T) {
	tracks := []SubtitleTrack{
		{LanguageCode: "ko", Name: "Korean (auto)", AutoGenerated: true},
		{LanguageCode: "en", Name: "English", AutoGenerated: false},
		{LanguageCode: "ko", Name: "Korean", AutoGenerated: false},
	}
	track, ok := chooseSubtitleTrack(tracks, "", SubtitlePolicy{
		PreferredLanguageCode: "ko",
		PreferAutoGenerated:   false,
	})
	if !ok {
		t.Fatalf("expected subtitle track")
	}
	if track.Name != "Korean" {
		t.Fatalf("selected track = %q, want Korean", track.Name)
	}
}

func TestGetTranscript_UnavailableTypedError(t *testing.T) {
	videoID := "jNQXAC9IVRw"
	httpClient := &http.Client{
		Transport: roundTripFunc(func(r *http.Request) (*http.Response, error) {
			if strings.HasPrefix(r.URL.Host, "caption.local") {
				return &http.Response{
					StatusCode: http.StatusNotFound,
					Header:     make(http.Header),
					Body:       io.NopCloser(bytes.NewBufferString(`missing`)),
				}, nil
			}
			t.Fatalf("unexpected request: %s", r.URL.String())
			return nil, nil
		}),
	}
	c := &Client{
		config: Config{HTTPClient: httpClient},
		sessions: map[string]videoSession{
			videoID: {
				Response: &innertube.PlayerResponse{
					VideoDetails: innertube.VideoDetails{VideoID: videoID},
					Captions: innertube.Captions{
						PlayerCaptionsTracklistRenderer: innertube.PlayerCaptionsTracklistRenderer{
							CaptionTracks: []innertube.CaptionTrack{
								{BaseURL: "https://caption.local/api?lang=en", LanguageCode: "en", Name: innertube.LangText{SimpleText: "English"}},
							},
						},
					},
				},
			},
		},
	}
	_, err := c.GetTranscript(context.Background(), videoID, "en")
	if !errors.Is(err, ErrUnavailable) {
		t.Fatalf("error = %v, want ErrUnavailable", err)
	}
	var detail *TranscriptUnavailableDetailError
	if !errors.As(err, &detail) {
		t.Fatalf("expected TranscriptUnavailableDetailError")
	}
}

func TestGetTranscript_ParseTypedError(t *testing.T) {
	videoID := "jNQXAC9IVRw"
	httpClient := &http.Client{
		Transport: roundTripFunc(func(r *http.Request) (*http.Response, error) {
			if strings.HasPrefix(r.URL.Host, "caption.local") {
				return &http.Response{
					StatusCode: http.StatusOK,
					Header:     make(http.Header),
					Body:       io.NopCloser(bytes.NewBufferString(`<bad xml>`)),
				}, nil
			}
			t.Fatalf("unexpected request: %s", r.URL.String())
			return nil, nil
		}),
	}
	c := &Client{
		config: Config{HTTPClient: httpClient},
		sessions: map[string]videoSession{
			videoID: {
				Response: &innertube.PlayerResponse{
					VideoDetails: innertube.VideoDetails{VideoID: videoID},
					Captions: innertube.Captions{
						PlayerCaptionsTracklistRenderer: innertube.PlayerCaptionsTracklistRenderer{
							CaptionTracks: []innertube.CaptionTrack{
								{BaseURL: "https://caption.local/api?lang=en", LanguageCode: "en", Name: innertube.LangText{SimpleText: "English"}},
							},
						},
					},
				},
			},
		},
	}
	_, err := c.GetTranscript(context.Background(), videoID, "en")
	if !errors.Is(err, ErrTranscriptParse) {
		t.Fatalf("error = %v, want ErrTranscriptParse", err)
	}
	var detail *TranscriptParseDetailError
	if !errors.As(err, &detail) {
		t.Fatalf("expected TranscriptParseDetailError")
	}
}

func TestGetPlaylist_ContinuationStopsByMaxRequests(t *testing.T) {
	html := `<html><script>var ytInitialData = {"responseContext":{"visitorData":"visitor"},"metadata":{"playlistMetadataRenderer":{"title":"My Playlist"}},"contents":[{"playlistVideoRenderer":{"videoId":"aaaaaaaaaaa","title":{"simpleText":"one"},"shortBylineText":{"runs":[{"text":"author1"}]},"lengthText":{"simpleText":"1:00"}}},{"continuationItemRenderer":{"continuationEndpoint":{"continuationCommand":{"token":"token-1"}}}}]};</script></html>`
	httpClient := &http.Client{
		Transport: roundTripFunc(func(r *http.Request) (*http.Response, error) {
			if r.Method == http.MethodGet && r.URL.Path == "/playlist" {
				return &http.Response{
					StatusCode: http.StatusOK,
					Header:     make(http.Header),
					Body:       io.NopCloser(bytes.NewBufferString(html)),
				}, nil
			}
			if r.Method == http.MethodPost && r.URL.Path == "/youtubei/v1/browse" {
				return jsonResponse(t, map[string]any{
					"onResponseReceivedActions": []any{
						map[string]any{
							"appendContinuationItemsAction": map[string]any{
								"continuationItems": []any{
									map[string]any{
										"continuationItemRenderer": map[string]any{
											"continuationEndpoint": map[string]any{
												"continuationCommand": map[string]any{
													"token": "token-2",
												},
											},
										},
									},
								},
							},
						},
					},
				}), nil
			}
			t.Fatalf("unexpected request: %s", r.URL.String())
			return nil, nil
		}),
	}
	c := &Client{config: Config{HTTPClient: httpClient, PlaylistContinuationMaxRequests: 1}}
	got, err := c.GetPlaylist(context.Background(), "https://www.youtube.com/playlist?list=PL1234567890")
	if err != nil {
		t.Fatalf("GetPlaylist() error = %v", err)
	}
	if !got.ContinuationStats.StoppedByLimit {
		t.Fatalf("expected stop by max request limit")
	}
	if len(got.ContinuationWarnings) == 0 || got.ContinuationWarnings[len(got.ContinuationWarnings)-1].Reason != "max_requests_reached" {
		t.Fatalf("unexpected warnings: %+v", got.ContinuationWarnings)
	}
}
