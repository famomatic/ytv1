package client

import (
	"context"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"html"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/famomatic/ytv1/internal/innertube"
)

// GetSubtitleTracks returns subtitle/caption tracks exposed by the player response.
func (c *Client) GetSubtitleTracks(ctx context.Context, input string) ([]SubtitleTrack, error) {
	ctx, cancel := withDefaultTimeout(ctx, c.config.RequestTimeout)
	defer cancel()

	session, _, err := c.ensureSession(ctx, input)
	if err != nil {
		return nil, err
	}
	tracks := session.Response.Captions.PlayerCaptionsTracklistRenderer.CaptionTracks
	out := make([]SubtitleTrack, 0, len(tracks))
	for _, t := range tracks {
		out = append(out, SubtitleTrack{
			LanguageCode:  t.LanguageCode,
			Name:          captionName(t.Name),
			BaseURL:       t.BaseURL,
			VssID:         t.VssID,
			Kind:          t.Kind,
			AutoGenerated: strings.EqualFold(strings.TrimSpace(t.Kind), "asr"),
		})
	}
	return out, nil
}

// GetTranscript fetches and parses transcript entries for a given language code.
// If languageCode is empty, the first available track is used.
func (c *Client) GetTranscript(ctx context.Context, input string, languageCode string) (*Transcript, error) {
	ctx, cancel := withDefaultTimeout(ctx, c.config.RequestTimeout)
	defer cancel()

	videoID, err := normalizeVideoID(input)
	if err != nil {
		return nil, err
	}
	tracks, err := c.GetSubtitleTracks(ctx, videoID)
	if err != nil {
		return nil, err
	}
	if len(tracks) == 0 {
		return nil, fmt.Errorf("%w: transcript unavailable", ErrUnavailable)
	}
	track, ok := chooseSubtitleTrack(tracks, languageCode)
	if !ok {
		return nil, fmt.Errorf("%w: language=%s", ErrUnavailable, languageCode)
	}

	raw, err := fetchTranscriptXML(ctx, c.httpClient(), c.config.RequestHeaders, track.BaseURL)
	if err != nil {
		return nil, err
	}
	entries, err := parseTranscriptXML(raw)
	if err != nil {
		return nil, err
	}
	return &Transcript{
		VideoID:      videoID,
		LanguageCode: track.LanguageCode,
		Name:         track.Name,
		Entries:      entries,
	}, nil
}

// GetPlaylist fetches and parses playlist metadata/items from playlist page initial data.
func (c *Client) GetPlaylist(ctx context.Context, input string) (*PlaylistInfo, error) {
	ctx, cancel := withDefaultTimeout(ctx, c.config.RequestTimeout)
	defer cancel()

	playlistID, err := ExtractPlaylistID(input)
	if err != nil {
		return nil, err
	}
	pageURL := "https://www.youtube.com/playlist?list=" + url.QueryEscape(playlistID) + "&hl=en"
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, pageURL, nil)
	if err != nil {
		return nil, err
	}
	applyRequestHeaders(req, c.config.RequestHeaders)
	resp, err := c.httpClient().Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("playlist fetch failed: status=%d", resp.StatusCode)
	}
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	initial, err := extractYTInitialData(body)
	if err != nil {
		return nil, err
	}
	var root any
	if err := json.Unmarshal(initial, &root); err != nil {
		return nil, err
	}

	info := &PlaylistInfo{
		ID:    playlistID,
		Title: findPlaylistTitle(root),
		Items: findPlaylistItems(root),
	}
	return info, nil
}

func (c *Client) httpClient() *http.Client {
	if c.config.HTTPClient != nil {
		return c.config.HTTPClient
	}
	return http.DefaultClient
}

func captionName(name innertube.LangText) string {
	if name.SimpleText != "" {
		return name.SimpleText
	}
	if len(name.Runs) == 0 {
		return ""
	}
	parts := make([]string, 0, len(name.Runs))
	for _, run := range name.Runs {
		if run.Text != "" {
			parts = append(parts, run.Text)
		}
	}
	return strings.Join(parts, "")
}

func chooseSubtitleTrack(tracks []SubtitleTrack, languageCode string) (SubtitleTrack, bool) {
	if len(tracks) == 0 {
		return SubtitleTrack{}, false
	}
	lc := strings.ToLower(strings.TrimSpace(languageCode))
	if lc == "" {
		return tracks[0], true
	}
	for _, t := range tracks {
		if strings.EqualFold(t.LanguageCode, lc) {
			return t, true
		}
	}
	for _, t := range tracks {
		if strings.HasPrefix(strings.ToLower(t.LanguageCode), lc+"-") {
			return t, true
		}
	}
	return SubtitleTrack{}, false
}

func fetchTranscriptXML(ctx context.Context, httpClient *http.Client, headers http.Header, baseURL string) ([]byte, error) {
	u, err := url.Parse(baseURL)
	if err != nil {
		return nil, err
	}
	q := u.Query()
	if q.Get("fmt") == "" {
		q.Set("fmt", "srv3")
	}
	u.RawQuery = q.Encode()

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, u.String(), nil)
	if err != nil {
		return nil, err
	}
	applyRequestHeaders(req, headers)
	resp, err := httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("transcript fetch failed: status=%d", resp.StatusCode)
	}
	return io.ReadAll(resp.Body)
}

func parseTranscriptXML(raw []byte) ([]TranscriptEntry, error) {
	type textNode struct {
		Start string `xml:"start,attr"`
		Dur   string `xml:"dur,attr"`
		Text  string `xml:",chardata"`
	}
	type transcriptDoc struct {
		Texts []textNode `xml:"text"`
	}
	var doc transcriptDoc
	if err := xml.Unmarshal(raw, &doc); err != nil {
		return nil, err
	}
	out := make([]TranscriptEntry, 0, len(doc.Texts))
	for _, n := range doc.Texts {
		start, err := parseFloatString(n.Start)
		if err != nil {
			continue
		}
		dur, _ := parseFloatString(n.Dur)
		text := strings.TrimSpace(html.UnescapeString(strings.ReplaceAll(n.Text, "\n", " ")))
		out = append(out, TranscriptEntry{
			StartSec: start,
			DurSec:   dur,
			Text:     text,
		})
	}
	return out, nil
}

func parseFloatString(s string) (float64, error) {
	var v float64
	if _, err := fmt.Sscanf(strings.TrimSpace(s), "%f", &v); err != nil {
		return 0, err
	}
	return v, nil
}

func extractYTInitialData(htmlBody []byte) ([]byte, error) {
	markers := []string{
		"var ytInitialData = ",
		"window[\"ytInitialData\"] = ",
		"ytInitialData = ",
	}
	body := string(htmlBody)
	for _, marker := range markers {
		pos := strings.Index(body, marker)
		if pos < 0 {
			continue
		}
		start := strings.Index(body[pos+len(marker):], "{")
		if start < 0 {
			continue
		}
		start += pos + len(marker)
		jsonBlob, ok := sliceJSONObject(body[start:])
		if ok {
			return []byte(jsonBlob), nil
		}
	}
	return nil, fmt.Errorf("ytInitialData not found")
}

func sliceJSONObject(s string) (string, bool) {
	if len(s) == 0 || s[0] != '{' {
		return "", false
	}
	depth := 0
	inString := false
	escaped := false
	for i := 0; i < len(s); i++ {
		ch := s[i]
		if inString {
			if escaped {
				escaped = false
				continue
			}
			if ch == '\\' {
				escaped = true
				continue
			}
			if ch == '"' {
				inString = false
			}
			continue
		}
		switch ch {
		case '"':
			inString = true
		case '{':
			depth++
		case '}':
			depth--
			if depth == 0 {
				return s[:i+1], true
			}
		}
	}
	return "", false
}

func findPlaylistTitle(root any) string {
	var title string
	walkAny(root, func(m map[string]any) {
		if title != "" {
			return
		}
		if v, ok := m["playlistMetadataRenderer"]; ok {
			if mm, ok := v.(map[string]any); ok {
				title = getStringFromMap(mm, "title")
			}
		}
	})
	return title
}

func findPlaylistItems(root any) []PlaylistItem {
	out := make([]PlaylistItem, 0, 32)
	walkAny(root, func(m map[string]any) {
		v, ok := m["playlistVideoRenderer"]
		if !ok {
			return
		}
		itemMap, ok := v.(map[string]any)
		if !ok {
			return
		}
		videoID := getStringFromMap(itemMap, "videoId")
		if videoID == "" {
			return
		}
		out = append(out, PlaylistItem{
			VideoID:         videoID,
			Title:           getTextField(itemMap["title"]),
			Author:          getTextField(itemMap["shortBylineText"]),
			DurationSeconds: getTextField(itemMap["lengthText"]),
		})
	})
	return out
}

func walkAny(v any, visitMap func(map[string]any)) {
	switch x := v.(type) {
	case map[string]any:
		visitMap(x)
		for _, vv := range x {
			walkAny(vv, visitMap)
		}
	case []any:
		for _, vv := range x {
			walkAny(vv, visitMap)
		}
	}
}

func getStringFromMap(m map[string]any, key string) string {
	v, ok := m[key]
	if !ok || v == nil {
		return ""
	}
	if s, ok := v.(string); ok {
		return s
	}
	return ""
}

func getTextField(v any) string {
	m, ok := v.(map[string]any)
	if !ok || m == nil {
		return ""
	}
	if s, ok := m["simpleText"].(string); ok && s != "" {
		return s
	}
	runs, ok := m["runs"].([]any)
	if !ok {
		return ""
	}
	parts := make([]string, 0, len(runs))
	for _, run := range runs {
		rm, ok := run.(map[string]any)
		if !ok {
			continue
		}
		if text, ok := rm["text"].(string); ok {
			parts = append(parts, text)
		}
	}
	return strings.Join(parts, "")
}
