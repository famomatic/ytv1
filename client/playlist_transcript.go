package client

import (
	"bytes"
	"context"
	"encoding/json"
	"encoding/xml"
	"errors"
	"fmt"
	"html"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/famomatic/ytv1/internal/innertube"
)

const defaultPlaylistContinuationMaxRequests = 100

// GetSubtitleTracks returns subtitle/caption tracks exposed by the player response.
func (c *Client) GetSubtitleTracks(ctx context.Context, input string) ([]SubtitleTrack, error) {
	ctx, cancel := withDefaultTimeout(ctx, c.config.RequestTimeout)
	defer cancel()

	session, _, err := c.ensureSession(ctx, input)
	if err != nil {
		return nil, err
	}
	tracks := session.Response.Captions.PlayerCaptionsTracklistRenderer.CaptionTracks
	out := make([]SubtitleTrack, 0, len(tracks))
	for _, t := range tracks {
		ext := ""
		if u, err := url.Parse(t.BaseURL); err == nil {
			ext = strings.TrimSpace(u.Query().Get("fmt"))
		}
		out = append(out, SubtitleTrack{
			LanguageCode:  t.LanguageCode,
			Name:          captionName(t.Name),
			BaseURL:       t.BaseURL,
			VssID:         t.VssID,
			Kind:          t.Kind,
			AutoGenerated: strings.EqualFold(strings.TrimSpace(t.Kind), "asr"),
			Ext:           ext,
		})
	}
	return out, nil
}

// GetTranscript fetches and parses transcript entries for a given language code.
// If languageCode is empty, the first available track is used.
func (c *Client) GetTranscript(ctx context.Context, input string, languageCode string) (*Transcript, error) {
	ctx, cancel := withDefaultTimeout(ctx, c.config.RequestTimeout)
	defer cancel()

	videoID, err := normalizeVideoID(input)
	if err != nil {
		return nil, err
	}
	tracks, err := c.GetSubtitleTracks(ctx, videoID)
	if err != nil {
		return nil, err
	}
	if len(tracks) == 0 {
		return nil, &TranscriptUnavailableDetailError{
			VideoID:      videoID,
			LanguageCode: languageCode,
			Reason:       "no caption tracks",
		}
	}
	track, ok := chooseSubtitleTrack(tracks, languageCode, c.config.SubtitlePolicy)
	if !ok {
		return nil, &TranscriptUnavailableDetailError{
			VideoID:      videoID,
			LanguageCode: languageCode,
			Reason:       "requested language not found",
		}
	}

	raw, err := fetchTranscriptXML(ctx, c.httpClient(), c.config.RequestHeaders, track.BaseURL)
	if err != nil {
		if errors.Is(err, ErrUnavailable) {
			return nil, &TranscriptUnavailableDetailError{
				VideoID:      videoID,
				LanguageCode: track.LanguageCode,
				Reason:       err.Error(),
			}
		}
		return nil, err
	}
	entries, err := parseTranscriptXML(raw)
	if err != nil {
		return nil, &TranscriptParseDetailError{
			VideoID:      videoID,
			LanguageCode: track.LanguageCode,
			Reason:       err.Error(),
		}
	}
	return &Transcript{
		VideoID:       videoID,
		LanguageCode:  track.LanguageCode,
		Name:          track.Name,
		AutoGenerated: track.AutoGenerated,
		SourceTrack:   track,
		Entries:       entries,
	}, nil
}

// GetPlaylist fetches and parses playlist metadata/items from playlist page initial data
// and continuation requests.
func (c *Client) GetPlaylist(ctx context.Context, input string) (*PlaylistInfo, error) {
	ctx, cancel := withDefaultTimeout(ctx, c.config.RequestTimeout)
	defer cancel()

	playlistID, err := ExtractPlaylistID(input)
	if err != nil {
		return nil, err
	}
	pageURL := "https://www.youtube.com/playlist?list=" + url.QueryEscape(playlistID) + "&hl=en"
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, pageURL, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Set("User-Agent", innertube.WebClient.UserAgent)
	req.Header.Set("Accept-Language", "en-US,en;q=0.9")
	applyRequestHeaders(req, c.config.RequestHeaders)
	resp, err := c.httpClient().Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("playlist fetch failed: status=%d", resp.StatusCode)
	}
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	initial, err := extractYTInitialData(body)
	if err != nil {
		return nil, err
	}
	var root any
	if err := json.Unmarshal(initial, &root); err != nil {
		return nil, err
	}

	info := &PlaylistInfo{
		ID:    playlistID,
		Title: findPlaylistTitle(root),
		Items: findPlaylistItems(root),
	}

	pendingContinuations := findContinuationTokens(root)
	visitorData := findVisitorData(root)
	seenContinuations := make(map[string]struct{}, len(pendingContinuations))
	maxRequests := c.config.PlaylistContinuationMaxRequests
	if maxRequests <= 0 {
		maxRequests = defaultPlaylistContinuationMaxRequests
	}

	for len(pendingContinuations) > 0 {
		if info.ContinuationStats.Requested >= maxRequests {
			info.ContinuationStats.StoppedByLimit = true
			info.ContinuationWarnings = append(info.ContinuationWarnings, PlaylistContinuationWarning{
				Token:  strings.TrimSpace(pendingContinuations[0]),
				Reason: "max_requests_reached",
			})
			break
		}
		continuation := strings.TrimSpace(pendingContinuations[0])
		pendingContinuations = pendingContinuations[1:]
		if continuation == "" {
			info.ContinuationStats.SkippedEmpty++
			continue
		}
		if _, seen := seenContinuations[continuation]; seen {
			info.ContinuationStats.SkippedDuplicate++
			continue
		}
		seenContinuations[continuation] = struct{}{}
		info.ContinuationStats.Requested++

		browseResp, err := c.browse(ctx, continuation, visitorData)
		if err != nil {
			// Fail gracefully on continuation error and continue remaining candidates.
			info.ContinuationStats.Failed++
			warn := continuationWarningFromError(continuation, err)
			info.ContinuationWarnings = append(info.ContinuationWarnings, warn)
			c.warnf("failed to fetch continuation: %v", err)
			continue
		}
		info.ContinuationStats.Succeeded++

		newItems, nextTokens := parseBrowseResponse(browseResp)
		info.Items = append(info.Items, newItems...)
		for _, token := range nextTokens {
			token = strings.TrimSpace(token)
			if token == "" {
				continue
			}
			if _, seen := seenContinuations[token]; seen {
				continue
			}
			pendingContinuations = append(pendingContinuations, token)
		}
	}

	return info, nil
}

func (c *Client) browse(ctx context.Context, continuation string, visitorData string) (*innertube.BrowseResponse, error) {
	clientProfile := innertube.WebClient
	req := innertube.NewBrowseRequest(clientProfile, "", continuation, innertube.PlayerRequestOptions{
		VisitorData: visitorData,
	})
	body, err := innertube.MarshalRequest(req)
	if err != nil {
		return nil, err
	}

	apiURL := "https://" + clientProfile.Host + "/youtubei/v1/browse?key=" + clientProfile.APIKey
	httpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, apiURL, bytes.NewReader(body))
	if err != nil {
		return nil, err
	}
	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("User-Agent", clientProfile.UserAgent)
	httpReq.Header.Set("Origin", "https://"+clientProfile.Host)

	// Add global request headers
	applyRequestHeaders(httpReq, c.config.RequestHeaders)

	resp, err := c.httpClient().Do(httpReq)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, &browseRequestError{StatusCode: resp.StatusCode}
	}

	var browseResp innertube.BrowseResponse
	if err := json.NewDecoder(resp.Body).Decode(&browseResp); err != nil {
		return nil, err
	}
	return &browseResp, nil
}

type browseRequestError struct {
	StatusCode int
}

func (e *browseRequestError) Error() string {
	return fmt.Sprintf("browse failed: status=%d", e.StatusCode)
}

func continuationWarningFromError(token string, err error) PlaylistContinuationWarning {
	warn := PlaylistContinuationWarning{
		Token:  token,
		Reason: "request_error",
	}
	var browseErr *browseRequestError
	if errors.As(err, &browseErr) {
		warn.Reason = "http_status_error"
		warn.HTTPStatus = browseErr.StatusCode
	}
	return warn
}

func findVisitorData(root any) string {
	var token string
	walkAny(root, func(m map[string]any) {
		if token != "" {
			return
		}
		// Look for responseContext -> visitorData
		if rc, ok := m["responseContext"].(map[string]any); ok {
			if v, ok := rc["visitorData"].(string); ok {
				token = v
			}
		}
	})
	return token
}

func (c *Client) httpClient() *http.Client {
	if c.config.HTTPClient != nil {
		return c.config.HTTPClient
	}
	return http.DefaultClient
}

func captionName(name innertube.LangText) string {
	if name.SimpleText != "" {
		return name.SimpleText
	}
	if len(name.Runs) == 0 {
		return ""
	}
	parts := make([]string, 0, len(name.Runs))
	for _, run := range name.Runs {
		if run.Text != "" {
			parts = append(parts, run.Text)
		}
	}
	return strings.Join(parts, "")
}

func chooseSubtitleTrack(tracks []SubtitleTrack, languageCode string, policy SubtitlePolicy) (SubtitleTrack, bool) {
	if len(tracks) == 0 {
		return SubtitleTrack{}, false
	}
	lc := strings.ToLower(strings.TrimSpace(languageCode))
	if lc != "" {
		if track, ok := findSubtitleTrackByLanguage(tracks, lc); ok {
			return track, true
		}
		return SubtitleTrack{}, false
	}

	if pref := strings.ToLower(strings.TrimSpace(policy.PreferredLanguageCode)); pref != "" {
		if track, ok := findSubtitleTrackByLanguage(tracks, pref); ok {
			if policy.PreferAutoGenerated || !track.AutoGenerated {
				return track, true
			}
			if manual, ok := findManualTrackByLanguage(tracks, pref); ok {
				return manual, true
			}
			return track, true
		}
	}

	for _, fallback := range policy.FallbackLanguageCodes {
		fallback = strings.ToLower(strings.TrimSpace(fallback))
		if fallback == "" {
			continue
		}
		if track, ok := findSubtitleTrackByLanguage(tracks, fallback); ok {
			if policy.PreferAutoGenerated || !track.AutoGenerated {
				return track, true
			}
			if manual, ok := findManualTrackByLanguage(tracks, fallback); ok {
				return manual, true
			}
			return track, true
		}
	}

	for _, track := range tracks {
		if !track.AutoGenerated {
			return track, true
		}
	}
	return tracks[0], true
}

func findSubtitleTrackByLanguage(tracks []SubtitleTrack, languageCode string) (SubtitleTrack, bool) {
	for _, track := range tracks {
		if strings.EqualFold(track.LanguageCode, languageCode) {
			return track, true
		}
	}
	for _, track := range tracks {
		if strings.HasPrefix(strings.ToLower(track.LanguageCode), languageCode+"-") {
			return track, true
		}
	}
	return SubtitleTrack{}, false
}

func findManualTrackByLanguage(tracks []SubtitleTrack, languageCode string) (SubtitleTrack, bool) {
	for _, track := range tracks {
		if track.AutoGenerated {
			continue
		}
		if strings.EqualFold(track.LanguageCode, languageCode) {
			return track, true
		}
	}
	for _, track := range tracks {
		if track.AutoGenerated {
			continue
		}
		if strings.HasPrefix(strings.ToLower(track.LanguageCode), languageCode+"-") {
			return track, true
		}
	}
	return SubtitleTrack{}, false
}

func fetchTranscriptXML(ctx context.Context, httpClient *http.Client, headers http.Header, baseURL string) ([]byte, error) {
	u, err := url.Parse(baseURL)
	if err != nil {
		return nil, err
	}
	q := u.Query()
	if q.Get("fmt") == "" {
		q.Set("fmt", "srv3")
	}
	u.RawQuery = q.Encode()

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, u.String(), nil)
	if err != nil {
		return nil, err
	}
	applyRequestHeaders(req, headers)
	resp, err := httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		if resp.StatusCode == http.StatusNotFound || resp.StatusCode == http.StatusForbidden || resp.StatusCode == http.StatusGone {
			return nil, fmt.Errorf("%w: transcript fetch failed: status=%d", ErrUnavailable, resp.StatusCode)
		}
		return nil, fmt.Errorf("transcript fetch failed: status=%d", resp.StatusCode)
	}
	return io.ReadAll(resp.Body)
}

func parseTranscriptXML(raw []byte) ([]TranscriptEntry, error) {
	type textNode struct {
		Start string `xml:"start,attr"`
		Dur   string `xml:"dur,attr"`
		Text  string `xml:",chardata"`
	}
	type transcriptDoc struct {
		Texts []textNode `xml:"text"`
	}
	var doc transcriptDoc
	if err := xml.Unmarshal(raw, &doc); err != nil {
		return nil, err
	}
	out := make([]TranscriptEntry, 0, len(doc.Texts))
	for _, n := range doc.Texts {
		start, err := parseFloatString(n.Start)
		if err != nil {
			continue
		}
		dur, _ := parseFloatString(n.Dur)
		text := strings.TrimSpace(html.UnescapeString(strings.ReplaceAll(n.Text, "\n", " ")))
		out = append(out, TranscriptEntry{
			StartSec: start,
			DurSec:   dur,
			Text:     text,
		})
	}
	return out, nil
}

func parseFloatString(s string) (float64, error) {
	var v float64
	if _, err := fmt.Sscanf(strings.TrimSpace(s), "%f", &v); err != nil {
		return 0, err
	}
	return v, nil
}

func extractYTInitialData(htmlBody []byte) ([]byte, error) {
	markers := []string{
		"var ytInitialData = ",
		"window[\"ytInitialData\"] = ",
		"ytInitialData = ",
	}
	body := string(htmlBody)
	for _, marker := range markers {
		pos := strings.Index(body, marker)
		if pos < 0 {
			continue
		}
		start := strings.Index(body[pos+len(marker):], "{")
		if start < 0 {
			continue
		}
		start += pos + len(marker)
		jsonBlob, ok := sliceJSONObject(body[start:])
		if ok {
			return []byte(jsonBlob), nil
		}
	}
	return nil, fmt.Errorf("ytInitialData not found")
}

func sliceJSONObject(s string) (string, bool) {
	if len(s) == 0 || s[0] != '{' {
		return "", false
	}
	depth := 0
	inString := false
	escaped := false
	for i := 0; i < len(s); i++ {
		ch := s[i]
		if inString {
			if escaped {
				escaped = false
				continue
			}
			if ch == '\\' {
				escaped = true
				continue
			}
			if ch == '"' {
				inString = false
			}
			continue
		}
		switch ch {
		case '"':
			inString = true
		case '{':
			depth++
		case '}':
			depth--
			if depth == 0 {
				return s[:i+1], true
			}
		}
	}
	return "", false
}

func findPlaylistTitle(root any) string {
	var title string
	walkAny(root, func(m map[string]any) {
		if title != "" {
			return
		}
		if v, ok := m["playlistMetadataRenderer"]; ok {
			if mm, ok := v.(map[string]any); ok {
				title = getStringFromMap(mm, "title")
			}
		}
	})
	return title
}

func findPlaylistItems(root any) []PlaylistItem {
	out := make([]PlaylistItem, 0, 32)
	walkAny(root, func(m map[string]any) {
		v, ok := m["playlistVideoRenderer"]
		if !ok {
			return
		}
		itemMap, ok := v.(map[string]any)
		if !ok {
			return
		}
		videoID := getStringFromMap(itemMap, "videoId")
		if videoID == "" {
			return
		}
		out = append(out, PlaylistItem{
			VideoID:         videoID,
			Title:           getTextField(itemMap["title"]),
			Author:          getTextField(itemMap["shortBylineText"]),
			DurationSeconds: getTextField(itemMap["lengthText"]),
			DurationSec:     parseDurationTextSeconds(getTextField(itemMap["lengthText"])),
		})
	})
	return out
}

func walkAny(v any, visitMap func(map[string]any)) {
	switch x := v.(type) {
	case map[string]any:
		visitMap(x)
		for _, vv := range x {
			walkAny(vv, visitMap)
		}
	case []any:
		for _, vv := range x {
			walkAny(vv, visitMap)
		}
	}
}

func getStringFromMap(m map[string]any, key string) string {
	v, ok := m[key]
	if !ok || v == nil {
		return ""
	}
	if s, ok := v.(string); ok {
		return s
	}
	return ""
}

func getTextField(v any) string {
	m, ok := v.(map[string]any)
	if !ok || m == nil {
		return ""
	}
	if s, ok := m["simpleText"].(string); ok && s != "" {
		return s
	}
	runs, ok := m["runs"].([]any)
	if !ok {
		return ""
	}
	parts := make([]string, 0, len(runs))
	for _, run := range runs {
		rm, ok := run.(map[string]any)
		if !ok {
			continue
		}
		if text, ok := rm["text"].(string); ok {
			parts = append(parts, text)
		}
	}
	return strings.Join(parts, "")
}

func findContinuationTokens(root any) []string {
	tokens := make([]string, 0, 2)
	seen := make(map[string]struct{})
	appendToken := func(token string) {
		token = strings.TrimSpace(token)
		if token == "" {
			return
		}
		if _, exists := seen[token]; exists {
			return
		}
		seen[token] = struct{}{}
		tokens = append(tokens, token)
	}
	walkAny(root, func(m map[string]any) {
		if cc, ok := m["continuationCommand"].(map[string]any); ok {
			appendToken(getStringFromMap(cc, "token"))
		}
		if ncd, ok := m["nextContinuationData"].(map[string]any); ok {
			appendToken(getStringFromMap(ncd, "continuation"))
		}
		if rcd, ok := m["reloadContinuationData"].(map[string]any); ok {
			appendToken(getStringFromMap(rcd, "continuation"))
		}
	})
	return tokens
}

func parseBrowseResponse(resp *innertube.BrowseResponse) ([]PlaylistItem, []string) {
	var items []PlaylistItem
	nextTokens := make([]string, 0, 2)
	seenTokens := make(map[string]struct{})
	appendToken := func(token string) {
		token = strings.TrimSpace(token)
		if token == "" {
			return
		}
		if _, exists := seenTokens[token]; exists {
			return
		}
		seenTokens[token] = struct{}{}
		nextTokens = append(nextTokens, token)
	}

	// Helper to extract items from a list of ContinuationItems
	extractFromItems := func(cItems []innertube.ContinuationItem) {
		for _, item := range cItems {
			if item.PlaylistVideoRenderer != nil {
				v := item.PlaylistVideoRenderer
				items = append(items, PlaylistItem{
					VideoID:         v.VideoID,
					Title:           captionName(v.Title),
					Author:          captionName(v.ShortBylineText),
					DurationSeconds: captionName(v.LengthText),
					DurationSec:     parseDurationTextSeconds(captionName(v.LengthText)),
				})
			}
			if item.ContinuationItemRenderer != nil {
				appendToken(item.ContinuationItemRenderer.ContinuationEndpoint.ContinuationCommand.Token)
			}
		}
	}

	for _, action := range resp.OnResponseReceivedActions {
		if action.AppendContinuationItemsAction != nil {
			extractFromItems(action.AppendContinuationItemsAction.ContinuationItems)
		}
		if action.ReloadContinuationItemsCommand != nil {
			extractFromItems(action.ReloadContinuationItemsCommand.ContinuationItems)
		}
	}
	for _, endpoint := range resp.OnResponseReceivedEndpoints {
		if endpoint.AppendContinuationItemsAction != nil {
			extractFromItems(endpoint.AppendContinuationItemsAction.ContinuationItems)
		}
		if endpoint.ReloadContinuationItemsCommand != nil {
			extractFromItems(endpoint.ReloadContinuationItemsCommand.ContinuationItems)
		}
	}
	// Also check contents -> twoColumnBrowseResultsRenderer -> tabs -> tabRenderer -> content -> sectionListRenderer -> contents -> itemSectionRenderer -> contents
	// But usually continuation returns actions.

	// If no actions, check if it's a reloaded browse response (rare for continuation but possible)
	if len(resp.OnResponseReceivedActions) == 0 && len(resp.OnResponseReceivedEndpoints) == 0 && resp.Contents.TwoColumnBrowseResultsRenderer != nil {
		for _, tab := range resp.Contents.TwoColumnBrowseResultsRenderer.Tabs {
			if tab.TabRenderer != nil && tab.TabRenderer.Content != nil && tab.TabRenderer.Content.SectionListRenderer != nil {
				for _, section := range tab.TabRenderer.Content.SectionListRenderer.Contents {
					if section.ItemSectionRenderer != nil {
						for _, item := range section.ItemSectionRenderer.Contents {
							if item.PlaylistVideoRenderer != nil {
								v := item.PlaylistVideoRenderer
								items = append(items, PlaylistItem{
									VideoID:         v.VideoID,
									Title:           captionName(v.Title),
									Author:          captionName(v.ShortBylineText),
									DurationSeconds: captionName(v.LengthText),
									DurationSec:     parseDurationTextSeconds(captionName(v.LengthText)),
								})
							}
						}
					}
					if section.ContinuationItemRenderer != nil {
						appendToken(section.ContinuationItemRenderer.ContinuationEndpoint.ContinuationCommand.Token)
					}
				}
			}
		}
	}

	return items, nextTokens
}

func parseDurationTextSeconds(text string) int64 {
	text = strings.TrimSpace(text)
	if text == "" {
		return 0
	}
	parts := strings.Split(text, ":")
	if len(parts) == 0 || len(parts) > 3 {
		return 0
	}
	var total int64
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			return 0
		}
		value, err := strconv.ParseInt(part, 10, 64)
		if err != nil || value < 0 {
			return 0
		}
		total = total*60 + value
	}
	return total
}
