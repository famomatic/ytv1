package cli

import (
	"context"
	"flag"
	"io"
	"os"
	"testing"
	"time"
)

func TestToClientConfig_StaticPoTokenProvider(t *testing.T) {
	cfg, err := ToClientConfig(Options{
		PoToken: "token-abc",
	})
	if err != nil {
		t.Fatalf("ToClientConfig() error = %v", err)
	}
	if cfg.PoTokenProvider == nil {
		t.Fatalf("expected PoTokenProvider to be configured")
	}
	token, err := cfg.PoTokenProvider.GetToken(context.Background(), "web")
	if err != nil {
		t.Fatalf("PoTokenProvider.GetToken() error = %v", err)
	}
	if token != "token-abc" {
		t.Fatalf("token = %q, want %q", token, "token-abc")
	}
}

func TestToClientConfig_EmptyPoTokenDoesNotConfigureProvider(t *testing.T) {
	cfg, err := ToClientConfig(Options{
		PoToken: "   ",
	})
	if err != nil {
		t.Fatalf("ToClientConfig() error = %v", err)
	}
	if cfg.PoTokenProvider != nil {
		t.Fatalf("expected PoTokenProvider to be nil for empty override")
	}
}

func TestToClientConfig_RetryOverrides(t *testing.T) {
	cfg, err := ToClientConfig(Options{
		DownloadRetries: 4,
		RetrySleepMS:    750,
	})
	if err != nil {
		t.Fatalf("ToClientConfig() error = %v", err)
	}
	if cfg.DownloadTransport.MaxRetries != 4 || cfg.MetadataTransport.MaxRetries != 4 {
		t.Fatalf("retry overrides not applied: download=%d metadata=%d", cfg.DownloadTransport.MaxRetries, cfg.MetadataTransport.MaxRetries)
	}
	wantBackoff := 750 * time.Millisecond
	if cfg.DownloadTransport.InitialBackoff != wantBackoff || cfg.MetadataTransport.InitialBackoff != wantBackoff {
		t.Fatalf("backoff overrides not applied: download=%s metadata=%s", cfg.DownloadTransport.InitialBackoff, cfg.MetadataTransport.InitialBackoff)
	}
}

func TestToClientConfig_SubtitlePolicyFromFlags(t *testing.T) {
	cfg, err := ToClientConfig(Options{
		SubLangs:      "ko, en ,ko",
		WriteAutoSubs: true,
	})
	if err != nil {
		t.Fatalf("ToClientConfig() error = %v", err)
	}
	if cfg.SubtitlePolicy.PreferredLanguageCode != "ko" {
		t.Fatalf("preferred language=%q, want ko", cfg.SubtitlePolicy.PreferredLanguageCode)
	}
	if len(cfg.SubtitlePolicy.FallbackLanguageCodes) != 1 || cfg.SubtitlePolicy.FallbackLanguageCodes[0] != "en" {
		t.Fatalf("fallback languages=%v, want [en]", cfg.SubtitlePolicy.FallbackLanguageCodes)
	}
	if !cfg.SubtitlePolicy.PreferAutoGenerated {
		t.Fatalf("PreferAutoGenerated=%v, want true", cfg.SubtitlePolicy.PreferAutoGenerated)
	}
}

func TestParseFlags_ShortJEnablesPrintJSON(t *testing.T) {
	origArgs := os.Args
	origFlagSet := flag.CommandLine
	defer func() {
		os.Args = origArgs
		flag.CommandLine = origFlagSet
	}()

	os.Args = []string{"ytv1", "-J", "jNQXAC9IVRw"}
	flag.CommandLine = flag.NewFlagSet(os.Args[0], flag.ContinueOnError)
	flag.CommandLine.SetOutput(io.Discard)

	opts := ParseFlags()
	if !opts.PrintJSON {
		t.Fatalf("PrintJSON=%v, want true", opts.PrintJSON)
	}
	if len(opts.URLs) != 1 || opts.URLs[0] != "jNQXAC9IVRw" {
		t.Fatalf("URLs=%v, want [jNQXAC9IVRw]", opts.URLs)
	}
}

func TestParseFlags_YTDLPCompatibilityAliases(t *testing.T) {
	origArgs := os.Args
	origFlagSet := flag.CommandLine
	defer func() {
		os.Args = origArgs
		flag.CommandLine = origFlagSet
	}()

	os.Args = []string{"ytv1", "--flat-playlist", "--extract-flat", "--no-playlist", "--yes-playlist", "--ignore-errors", "--continue", "-j", "--dump-json", "jNQXAC9IVRw"}
	flag.CommandLine = flag.NewFlagSet(os.Args[0], flag.ContinueOnError)
	flag.CommandLine.SetOutput(io.Discard)

	opts := ParseFlags()
	if !opts.FlatPlaylist {
		t.Fatalf("FlatPlaylist=%v, want true", opts.FlatPlaylist)
	}
	if opts.NoPlaylist {
		t.Fatalf("NoPlaylist=%v, want false because --yes-playlist overrides it", opts.NoPlaylist)
	}
	if !opts.YesPlaylist {
		t.Fatalf("YesPlaylist=%v, want true", opts.YesPlaylist)
	}
	if opts.AbortOnError {
		t.Fatalf("AbortOnError=%v, want false because --ignore-errors overrides it", opts.AbortOnError)
	}
	if opts.NoContinue {
		t.Fatalf("NoContinue=%v, want false", opts.NoContinue)
	}
	if !opts.PrintJSON {
		t.Fatalf("PrintJSON=%v, want true from -j/--dump-json", opts.PrintJSON)
	}
	if len(opts.URLs) != 1 || opts.URLs[0] != "jNQXAC9IVRw" {
		t.Fatalf("URLs=%v, want [jNQXAC9IVRw]", opts.URLs)
	}
}

func TestParseFlags_SubFormatSingleDashCompatibility(t *testing.T) {
	origArgs := os.Args
	origFlagSet := flag.CommandLine
	defer func() {
		os.Args = origArgs
		flag.CommandLine = origFlagSet
	}()

	os.Args = []string{"ytv1", "-sub-format", "vtt", "jNQXAC9IVRw"}
	flag.CommandLine = flag.NewFlagSet(os.Args[0], flag.ContinueOnError)
	flag.CommandLine.SetOutput(io.Discard)

	opts := ParseFlags()
	if opts.SubFormat != "vtt" {
		t.Fatalf("SubFormat=%q, want vtt", opts.SubFormat)
	}
	if len(opts.URLs) != 1 || opts.URLs[0] != "jNQXAC9IVRw" {
		t.Fatalf("URLs=%v, want [jNQXAC9IVRw]", opts.URLs)
	}
}

func TestParseFlags_SubLangsAliasSingleDashCompatibility(t *testing.T) {
	origArgs := os.Args
	origFlagSet := flag.CommandLine
	defer func() {
		os.Args = origArgs
		flag.CommandLine = origFlagSet
	}()

	os.Args = []string{"ytv1", "-sub-langs", "ko,en", "jNQXAC9IVRw"}
	flag.CommandLine = flag.NewFlagSet(os.Args[0], flag.ContinueOnError)
	flag.CommandLine.SetOutput(io.Discard)

	opts := ParseFlags()
	if opts.SubLangs != "ko,en" {
		t.Fatalf("SubLangs=%q, want ko,en", opts.SubLangs)
	}
	if len(opts.URLs) != 1 || opts.URLs[0] != "jNQXAC9IVRw" {
		t.Fatalf("URLs=%v, want [jNQXAC9IVRw]", opts.URLs)
	}
}

func TestParseFlags_WriteSRTAliasForcesSRTOutput(t *testing.T) {
	origArgs := os.Args
	origFlagSet := flag.CommandLine
	defer func() {
		os.Args = origArgs
		flag.CommandLine = origFlagSet
	}()

	os.Args = []string{"ytv1", "-write-srt", "-sub-format", "vtt", "jNQXAC9IVRw"}
	flag.CommandLine = flag.NewFlagSet(os.Args[0], flag.ContinueOnError)
	flag.CommandLine.SetOutput(io.Discard)

	opts := ParseFlags()
	if !opts.WriteSubs {
		t.Fatalf("WriteSubs=%v, want true", opts.WriteSubs)
	}
	if opts.SubFormat != "srt" {
		t.Fatalf("SubFormat=%q, want srt", opts.SubFormat)
	}
	if len(opts.URLs) != 1 || opts.URLs[0] != "jNQXAC9IVRw" {
		t.Fatalf("URLs=%v, want [jNQXAC9IVRw]", opts.URLs)
	}
}

func TestParseFlags_DumpSingleJSON(t *testing.T) {
	origArgs := os.Args
	origFlagSet := flag.CommandLine
	defer func() {
		os.Args = origArgs
		flag.CommandLine = origFlagSet
	}()

	os.Args = []string{"ytv1", "--dump-single-json", "jNQXAC9IVRw"}
	flag.CommandLine = flag.NewFlagSet(os.Args[0], flag.ContinueOnError)
	flag.CommandLine.SetOutput(io.Discard)

	opts := ParseFlags()
	if !opts.DumpSingleJSON {
		t.Fatalf("DumpSingleJSON=%v, want true", opts.DumpSingleJSON)
	}
	if len(opts.URLs) != 1 || opts.URLs[0] != "jNQXAC9IVRw" {
		t.Fatalf("URLs=%v, want [jNQXAC9IVRw]", opts.URLs)
	}
}
